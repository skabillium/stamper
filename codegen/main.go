package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
)

type GetLicensesResponse struct {
	Key    string `json:"key"`
	Name   string `json:"name"`
	SpdxId string `json:"spdx_id"`
	Url    string `json:"url"`
	NodeId string `json:"node_id"`
}

func GetLicenses() ([]GetLicensesResponse, error) {
	res, err := http.Get("http://api.github.com/licenses")
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var licenses []GetLicensesResponse
	err = json.Unmarshal(body, &licenses)
	if err != nil {
		return nil, err
	}

	return licenses, nil
}

type GetLicenseReponse struct {
	Body string `json:"body"`
}

func GetLicense(url string) (*GetLicenseReponse, error) {
	res, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var license *GetLicenseReponse
	err = json.Unmarshal(body, &license)
	if err != nil {
		return nil, err
	}

	return license, nil
}

func WriteLicenseFiles(licenses []GetLicensesResponse) {
	for _, license := range licenses {
		details, err := GetLicense(license.Url)
		if err != nil {
			panic(err)
		}

		filename := "licenses/" + license.SpdxId
		file, err := os.Create(filename)
		if err != nil {
			panic(err)
		}
		defer file.Close()

		_, err = file.WriteString(details.Body)
		if err != nil {
			panic(err)
		}

		fmt.Println("Created file:", filename)
	}
}

func GenerateConstantsFile() {
	var ConstantNames = map[string]string{
		"agpl-3.0":     "Apl3Body",
		"apache-2.0":   "Apache2Body",
		"bsd-2-clause": "Bsd2ClauseBody",
		"bsd-3-clause": "Bsd3ClauseBody",
		"bsl-1.0":      "Bsl1Body",
		"cc0-1.0":      "Cc01Body",
		"epl-2.0":      "Epl2Body",
		"gpl-2.0":      "Gpl2Body",
		"gpl-3.0":      "Gpl3Body",
		"lgpl-2.1":     "Lgpl2Body",
		"mit":          "MitBody",
		"mpl-2.0":      "Mpl2Body",
		"unlicense":    "UnlicenseBody",
	}

	res, err := os.ReadFile("licenses/licenses.json")
	if err != nil {
		panic(err)
	}

	var licenses []GetLicensesResponse
	err = json.Unmarshal(res, &licenses)
	if err != nil {
		panic(err)
	}

	bodiesFile, err := os.Create("cmd/license_bodies.go")
	if err != nil {
		panic(err)
	}

	const LicensesFile = "cmd/licenses.go"
	licensesFile, err := os.Create(LicensesFile)
	if err != nil {
		panic(err)
	}
	defer licensesFile.Close()

	licensesFile.WriteString("package main\n\n")
	licensesFile.WriteString(`type License struct {
	Name string
	Aliases []string
	HasParams bool
	Body string
}

`)

	licensesFile.WriteString("var Licenses = map[string]License{\n")

	bodiesFile.WriteString("// File generated by codegen/main.go DO NOT EDIT\n")
	bodiesFile.WriteString("package main\n\n")

	for _, l := range licenses {
		txt, err := os.ReadFile("licenses/" + l.SpdxId)
		if err != nil {
			panic(err)
		}

		constant, ok := ConstantNames[l.Key]
		if !ok {
			panic("Error for license " + l.Key)
		}

		formatted := strings.ReplaceAll(string(txt), "\n", "\\n")
		formatted = strings.ReplaceAll(formatted, "\t", "\\t")
		formatted = strings.ReplaceAll(formatted, "\"", "\\\"")

		bodiesFile.WriteString(fmt.Sprintf("const %s = \"%s\" \n\n", constant, formatted))

		hasParams := strings.Contains(formatted, "[year]")
		hasParamsStr := "false"
		if hasParams {
			hasParamsStr = "true"
		}

		licensesFile.WriteString(fmt.Sprintf(`	"%s": {
		Name: "%s",
		Aliases: []string{},
		HasParams: %s,
		Body: %s,
	},
`, l.Key, strings.ReplaceAll(l.Name, "\"", "\\\""), hasParamsStr, constant))
	}
	licensesFile.WriteString("}\n")
}

func main() {
	GenerateConstantsFile()
}
